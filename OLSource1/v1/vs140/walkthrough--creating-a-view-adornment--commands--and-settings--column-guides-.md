---
title: "Walkthrough: Creating a View Adornment, Commands, and Settings (Column Guides)"
ms.custom: na
ms.date: "09/22/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: na
ms.suite: na
ms.technology: 
  - "vs-ide-sdk"
ms.tgt_pltfrm: na
ms.topic: "article"
ms.assetid: 4a2df0a3-42da-4f7b-996f-ee16a35ac922
caps.latest.revision: 11
ms.author: "gregvanl"
translation.priority.mt: 
  - "de-de"
  - "ja-jp"
---
# Walkthrough: Creating a View Adornment, Commands, and Settings (Column Guides)
You can extend the Visual Studio text/code editor with commands and view effects.  This topic shows you how to get started with a popular extension feature, column guides.  Column guides are visually light lines drawn on the text editor’s view to help you manage your code to specific column widths.  Specifically formatted code can be important for samples you include in documents, blog posts, or bug reports.  
  
 In this walkthrough, you will:  
  
-   Create a VSIX project  
  
-   Add an editor view adornment  
  
-   Add support for saving and getting settings (where to draw column guides and their color)  
  
-   Add commands (add/remove column guides, change their color)  
  
-   Place the commands on the Edit menu and text document context menus  
  
-   Add support for invoking the commands from the Visual Studio Command Window  
  
 You can try out a version of the column guides feature with this Visual Studio Gallery[extension](https://visualstudiogallery.msdn.microsoft.com/da227a0b-0e31-4a11-8f6b-3a149cf2e459?SRC=Home).  
  
 **NOTE**: in this walkthrough you paste a lot of code into a few files generated by visual studio extension templates, but soon this walkthrough will refer to a completed solution on github with other extension examples.  The completed code is slightly different in that it has real command icons instead of using generictemplate icons.  
  
## Getting Started  
 Starting in Visual Studio 2015, you do not install the Visual Studio SDK from the download center. It is included as an optional feature in Visual Studio setup. You can also install the VS SDK later on. For more information, see [Installing the Visual Studio SDK](../vs140/installing-the-visual-studio-sdk.md).  
  
## Setting up the Solution  
 First you will create a VSIX project, add an editor view adornment, and then add a command (which adds a VSPackage to own the command).  The basic architecture is as follows:  
  
-   You have a text view creation listener that creates a <CodeContentPlaceHolder>24\</CodeContentPlaceHolder> object per view.  This object listens for events about the view changing or settings changing, updating or redrawing column guides as necessary.  
  
-   There is a <CodeContentPlaceHolder>25\</CodeContentPlaceHolder> that handles reading and writing from the Visual Studio settings storage.  The settings manager also has operations for updating the settings that support the user commands (add column, remove column, change color).  
  
-   There is a VSIP package that is necessary if you have user commands, but it is just boilerplate code that initializes the commands implementation object.  
  
-   There is a <CodeContentPlaceHolder>26\</CodeContentPlaceHolder> object that implements the user commands and hooks up the command handlers for commands declared in the .vsct file.  
  
 **VSIX**.  Use **File &#124; New …** command to create a project.  Choose the Extensibility node under C# in the left navigation pane and choose **VSIX Project** in the right pane.  Enter the name ColumnGuides and choose **OK** to create the project.  
  
 **View adornment**.  Press the right pointer button on the project node in the Solution Explorer.  Choose the **Add &#124; New Item …** command to add a new view adornment item.  Choose **Extensibility &#124; Editor** in the left navigation pane and choose **Editor Viewport Adornment** in the right pane.  Enter the name ColumnGuideAdornment as the item name and choose **Add** to add it.  
  
 You can see this item template added two files to the project (as well as references and so on): ColumnGuideAdornment.cs and ColumnGuideAdornmentTextViewCreationListener.cs.  The templates just draw a purple rectangle on the view.  Below you will change a couple of lines in the view creation listener and replace the contents of ColumnGuideAdornment.cs.  
  
 **Commands**.  Press the right pointer button on the project node in the Solution Explorer.  Choose the **Add &#124; New Item …** command to add a new view adornment item.  Choose **Extensibility &#124; VSPackage** in the left navigation pane and choose **Custom Command** in the right pane.  Enter the name ColumnGuideCommands as the item name and choose **Add** to add it.  In addition to several references, adding the commands and package added ColumnGuideCommands.cs, ColumnGuideCommandsPackage.cs, and ColumnGuideCommandsPackage.vsct.  Below you will replace the contents of first and last files to define and implement the commands.  
  
## Setting up the Text View Creation Listener  
 Open ColumnGuideAdornmentTextViewCreationListener.cs in the editor.  This code implements a handler for whenever Visual Studio creates text views.  There are attributes that control when the handler is called depending on characteristics of the view.  
  
 The code also must declare an adornment layer.  When the editor updates views, it gets the adornment layers for the view and from that gets the adornment elements.  You can declare the ordering of your layer relative to others with attributes.  Replace the following line:  
  
<CodeContentPlaceHolder>0\</CodeContentPlaceHolder>  
 with these two lines:  
  
<CodeContentPlaceHolder>1\</CodeContentPlaceHolder>  
 The line you replaced is in a group of attributes that declare an adornment layer.   The first line you changed only changes where the column guide lines appear.  Drawing the lines “before” the text in the view means they appear behind or below the text.  The second line declares that the column guide adornments are applicable to text entities that fit your notion of a document, but you could declare the adornment, for example, to only work for editable text.  There is more information in [Editor Extension Points](../vs140/language-service-and-editor-extension-points.md)  
  
## Implementing the Settings Manager  
 Replace the contents of the GuidesSettingsManager.cs with the following code (explained below):  
  
<CodeContentPlaceHolder>2\</CodeContentPlaceHolder>  
 Most of this code just creates and parses the settings format: "RGB(\<int>,\<int>,\<int>) \<int>, \<int>, …".  The integers at the end are the one-based columns where you want column guides.  The column guides extension captures all its settings in a single setting value string.  
  
 There are some parts of the code worth highlighting.  The following line of code gets the Visual Studio managed wrapper for the settings storage.  For the most part, this abstracts over the Windows registry, but this API is independent of the storage mechanism.  
  
<CodeContentPlaceHolder>3\</CodeContentPlaceHolder>  
 The Visual Studio settings storage uses a category identifier and a setting identifier to uniquely identify all settings:  
  
<CodeContentPlaceHolder>4\</CodeContentPlaceHolder>  
 You do not have to use <CodeContentPlaceHolder>27\</CodeContentPlaceHolder> as the category name, and you can pick anything you like.  
  
 The first few functions are the entry points to change settings.  They check high-level constraints like maximum number of guides allowed.  Then they call <CodeContentPlaceHolder>28\</CodeContentPlaceHolder> which composes a settings string and sets the property <CodeContentPlaceHolder>29\</CodeContentPlaceHolder>.  Setting this property saves the settings value to the Visual Studio settings store and fires the <CodeContentPlaceHolder>30\</CodeContentPlaceHolder> event to update all the <CodeContentPlaceHolder>31\</CodeContentPlaceHolder> objects, each associated with a text view.  
  
 There are a couple of entry point functions, such as <CodeContentPlaceHolder>32\</CodeContentPlaceHolder>, that are used to implement commands that change settings.  When Visual Studio shows menus, it queries command implementations to see if the command is currently enabled, what its name is, etc.  Below you will see how to hook up these entry points for the command implementations.  See [Extending VS Menus and Commands](../vs140/extending-menus-and-commands.md) for more information on commands.  
  
## Implementing the ColumnGuideAdornment Class  
 The <CodeContentPlaceHolder>33\</CodeContentPlaceHolder> class is instantiated for each text view that can have adornments.  This class listens for events about the view changing or settings changing, updating or redrawing column guides as necessary.  
  
 Replace the contents of the ColumnGuideAdornment.cs with the following code (explained below):  
  
<CodeContentPlaceHolder>5\</CodeContentPlaceHolder>  
 Instances of this class hold onto the associated \<xref:Microsoft.VisualStudio.Text.Editor.IWpfTextView*> and a list of <CodeContentPlaceHolder>34\</CodeContentPlaceHolder> objects drawn on the view.  
  
 The constructor (called from <CodeContentPlaceHolder>35\</CodeContentPlaceHolder> when Visual Studio creates new views) creates the column guide <CodeContentPlaceHolder>36\</CodeContentPlaceHolder> objects.  The constructor also adds handlers for the <CodeContentPlaceHolder>37\</CodeContentPlaceHolder> event (defined in <CodeContentPlaceHolder>38\</CodeContentPlaceHolder>) and the view events <CodeContentPlaceHolder>39\</CodeContentPlaceHolder> and <CodeContentPlaceHolder>40\</CodeContentPlaceHolder>.  
  
 The <CodeContentPlaceHolder>41\</CodeContentPlaceHolder> event fires due to several kinds of changes in the view, including when Visual Studio creates the view.  The <CodeContentPlaceHolder>42\</CodeContentPlaceHolder> handler calls <CodeContentPlaceHolder>43\</CodeContentPlaceHolder> to execute.  The code in <CodeContentPlaceHolder>44\</CodeContentPlaceHolder> determines if it needs to update line positions based on changes such as font size changes, view gutters, horizontal scrolling, and so on.  The code in <CodeContentPlaceHolder>45\</CodeContentPlaceHolder> causes guide lines to draw between characters or just after the column of text that is in the specified character offset in the line of text.  
  
 Whenever settings change the <CodeContentPlaceHolder>46\</CodeContentPlaceHolder> function just recreates all the <CodeContentPlaceHolder>47\</CodeContentPlaceHolder> objects with whatever the new settings are.  After setting the line positions, the code removes all previous <CodeContentPlaceHolder>48\</CodeContentPlaceHolder> objects from the <CodeContentPlaceHolder>49\</CodeContentPlaceHolder> adornment layer and adds the new ones.  
  
## Defining the Commands, Menus, and Menu Placements  
 There can be a lot to declaring commands and menus, placing groups of commands or menus on various other menus, and hooking up command handlers.  This walkthrough highlights how commands work in this extension, but for deeper information, see [Extending VS Menus and Commands](../vs140/extending-menus-and-commands.md).  
  
### Introduction to the Code  
 The Column Guides extension shows declaring a group of commands that belong together (add column, remove column, change line color), and then placing that group on a sub menu of the editor’s context menu.  The Column Guides extension also adds the commands to the main **Edit** menu but keeps them invisible, discussed as a common pattern below.  
  
 There are three parts to the commands implementation: ColumnGuideCommandsPackage.cs, ColumnGuideCommandsPackage.vsct, and ColumnGuideCommands.cs.  The code generated by the templates puts a command on the **Tools** menu that pops a dialog box as the implementation.  You can look at how that is implemented in the .vsct and ColumnGuideCommands.cs files since it is pretty straightforward.  You will replace the code in these files below.  
  
 The package code is boilerplate declarations that are required for Visual Studio to discover that the extension offers commands and where to place the commands.  When the package initializes, it instantiate the commands implementation class.  See the commands link above for more info about packages relating to commands.  
  
### A Common Commands Pattern  
 The commands in the Column Guides extension are an example of a very common pattern in Visual Studio.  You put related commands in a group, and you put that group on a main menu, often with “<CodeContentPlaceHolder>50\</CodeContentPlaceHolder>” set to make the command invisible.  Putting commands on the main menus (such as **Edit**) this way gives them nice names (such as **Edit.AddColumnGuide**) which are useful for finding commands when re-assigning key bindings in **Tools Options** and for getting completion when invoking commands from the **Command Window**.  
  
 You then add the group of commands to context menus or sub menus where you expect user to use the commands.  Visual Studio treats <CodeContentPlaceHolder>51\</CodeContentPlaceHolder> as an invisibility flag for main menus only.  When you place the same group of commands on a context menu or sub menu, the commands are visible.  
  
 As part of the common pattern, the Column Guides extension creates a second group that holds a single sub menu.  The sub menu in turn contains the first group with the four column guide commands.  The second group that holds the sub menu is the re-usable asset that you place on various context menus, which puts a sub menu on those context menus.  
  
### The .vsct File  
 The .vsct file declares the commands and where they go, along with icons and so on.  Replace the contents of the .vsct file with the following code (explained below):  
  
<CodeContentPlaceHolder>6\</CodeContentPlaceHolder>  
 **GUIDS**.  For Visual Studio to find your command handlers and invoke them, you need to ensure the package GUID declared in the ColumnGuideCommandsPackage.cs file (generated from the project item template) matches the package GUID declared in the .vsct file (copied from above).  If you re-use this sample code, you should make sure you have a different GUID so that you do not conflict with anyone else who may have copied this code.  
  
 Find this line in ColumnGuideCommandsPackage.cs and copy the GUID from between the quotation marks:  
  
<CodeContentPlaceHolder>7\</CodeContentPlaceHolder>  
 Then paste the GUID in the .vsct file so that you have the following line in your <CodeContentPlaceHolder>52\</CodeContentPlaceHolder> declarations:  
  
<CodeContentPlaceHolder>8\</CodeContentPlaceHolder>  
 The GUIDs for the command set and the bitmap image file should be unique for your extensions too:  
  
<CodeContentPlaceHolder>9\</CodeContentPlaceHolder>  
 However, you do not need to change the command set and bitmap image GUIDs in this walkthrough to get the code to work.  The command set GUID needs to match the declaration in the ColumnGuideCommands.cs file, but you will replace the contents of that file too; therefore, the GUIDs will match.  
  
 Other GUIDs in the .vsct file identify pre-existing menus to which the column guide commands are added, so they never change.  
  
 **File sections**.  The .vsct has three outer sections: commands, placements, and symbols.  The commands section defines command groups, menus, buttons or menu items, and bitmaps for icons.  The placements section declares where groups go on menus or additional placements onto pre-existing menus.  The symbols section declares identifiers used elsewhere in the .vsct file, which makes the .vsct code more readable than having GUIDs and hex numbers everywhere.  
  
 **Commands section, groups definitions**.  The commands section first defines command groups.  Groups of commands are commands you see in menus with slight grey lines separating the groups.  A group may also fill an entire sub menu, as in this example, and you do not see the grey separating lines in this case.  The .vsct files declares two groups, the <CodeContentPlaceHolder>53\</CodeContentPlaceHolder> that is parented to the <CodeContentPlaceHolder>54\</CodeContentPlaceHolder> (the main **Edit** menu) and the <CodeContentPlaceHolder>55\</CodeContentPlaceHolder> that is parented to the <CodeContentPlaceHolder>56\</CodeContentPlaceHolder> (the code editor’s context menu).  
  
 The second group declaration has a <CodeContentPlaceHolder>57\</CodeContentPlaceHolder> priority:  
  
<CodeContentPlaceHolder>10\</CodeContentPlaceHolder>  
 The idea is to put the column guides sub menu at the end of any context menu to which we add the sub menu group.  However, you should not assume you know best and force the sub menu to always be last by using a priority of <CodeContentPlaceHolder>58\</CodeContentPlaceHolder>.  You have to play around with this number to see where your sub menu lies on the context menus where you place it.  In this case <CodeContentPlaceHolder>59\</CodeContentPlaceHolder> is high enough to put it at the end of the menus as far as we can see, but it leaves room for someone else to design their extension to be lower than the column guides extension if that’s desirable.  
  
 **Commands section, menu definition**.  Next the command section defines the sub menu <CodeContentPlaceHolder>60\</CodeContentPlaceHolder>, parented to the <CodeContentPlaceHolder>61\</CodeContentPlaceHolder>.  The <CodeContentPlaceHolder>62\</CodeContentPlaceHolder> is the group we add to all the relevant context menus.  In the placements section, the code places the group with the four column guide commands on this sub menu.  
  
 **Commands section, buttons definitions**.  The commands section then defines the menu items or buttons that are the four column guides commands.  <CodeContentPlaceHolder>63\</CodeContentPlaceHolder>, discussed above, means the commands are invisible when placed on a main menu.  Two of the menu item button declarations (add guide and remove guide) also have an <CodeContentPlaceHolder>64\</CodeContentPlaceHolder> flag:  
  
<CodeContentPlaceHolder>11\</CodeContentPlaceHolder>  
 This flag enables, along with having main menu placements, the command to receive arguments when Visual Studio invokes the command handler.  If the user invokes the command from the Command Window, the argument gets passed to the command handler in the event arguments.  
  
 **Command sections, bitmaps definitions**.  Lastly the commands section declares the bitmaps or icons used for the commands.  This is a simple declaration that identifies the project resource and lists one-based indexes of used icons.  The symbols section of the .vsct file declares the values of the identifiers used as indexes.  This walkthrough uses the bitmap strip provided with the custom command item template added to the project.  
  
 **Placements section**.  After the commands section is the placements section.  The first one is where the code adds the first group discussed above that holds the four column guide commands to the sub menu where the commands appear:  
  
<CodeContentPlaceHolder>12\</CodeContentPlaceHolder>  
 All of the other placements add the <CodeContentPlaceHolder>65\</CodeContentPlaceHolder> (which contains the <CodeContentPlaceHolder>66\</CodeContentPlaceHolder>) to other editor context menus.  When the code declared the <CodeContentPlaceHolder>67\</CodeContentPlaceHolder>, it was parented to the code editor’s context menu.  That is why you do not see a placement for the code editor’s context menu.  
  
 **Symbols section**.  As stated above, the symbols section declares identifiers used elsewhere in the .vsct file, which makes the .vsct code more readable than having GUIDs and hex numbers everywhere.  The important points in this section are that the package GUID must agree with the declaration in the package class, and the command set GUID must agree with the declaration in the command implementation class.  
  
## Implementing the Commands  
 The ColumnGuideCommands.cs file implements the commands and hooks up the handlers.  When Visual Studio loads the package and initializes it, the package in turn calls <CodeContentPlaceHolder>68\</CodeContentPlaceHolder> on the commands implementation class.  The commands initialization simply instantiates the class, and the constructor hooks up all the command handlers.  
  
 Replace the contents of the ColumnGuideCommands.cs file with the following code (explained below):  
  
<CodeContentPlaceHolder>13\</CodeContentPlaceHolder>  
 **Fix references**.  You are missing a reference at this point.  Press the right pointer button on the References node in the Solution Explorer.  Choose the **Add …** command.  The **Add Reference** dialog has a search box in the upper right corner.  Enter “editor” (without the double quotes).  Choose the **Microsoft.VisualStudio.Editor** item (you must check the box to the left of the item, not just select the item) and choose **OK** to add the reference.  
  
 **Initialization**.  When the package class initializes, it calls <CodeContentPlaceHolder>69\</CodeContentPlaceHolder> on the commands implementation class.  The <CodeContentPlaceHolder>70\</CodeContentPlaceHolder> initialization instantiates the class and saves the class instance and the package reference in class members.  
  
 Let’s look at one of the command handler hook ups from the class constructor:  
  
<CodeContentPlaceHolder>14\</CodeContentPlaceHolder>  
 You create an <CodeContentPlaceHolder>71\</CodeContentPlaceHolder>.  Visual Studio uses the Microsoft Office command system.  The key arguments when instantiating an OleMenuCommand is the function that implements the command (<CodeContentPlaceHolder>72\</CodeContentPlaceHolder>), the function to call when Visual Studio shows a menu with the command (<CodeContentPlaceHolder>73\</CodeContentPlaceHolder>), and the command ID.  Visual studio calls the query status function before showing a command on a menu so that the command can make itself invisible or greyed out for a particular display of the menu (for example, disabling **Copy** if there’s no selection), change its icon, or even change its name (for example, from Add Something to Remove Something), and so on.  The command ID must match a command ID declared in the .vsct file.  The strings for the command set and the column guides add command must match between the .vsct file and the ColumnGuideCommands.cs.  
  
 The following line provides assistance for when users invoke the command via the Command Window (explained below):  
  
<CodeContentPlaceHolder>15\</CodeContentPlaceHolder>  
 **Query status**.  The query status functions <CodeContentPlaceHolder>74\</CodeContentPlaceHolder> and <CodeContentPlaceHolder>75\</CodeContentPlaceHolder> check some settings (such as max number of guides or max column) or if there is a column guide to remove.  They enable the commands if the conditions are right.  Query status functions need to be very efficient because they run every time Visual Studio shows a menu, for each command on the menu.  
  
 **AddColumnGuideExecuted function**.  The interesting part of adding a guide is figuring out the current editor view and caret location.  First this function calls <CodeContentPlaceHolder>76\</CodeContentPlaceHolder> which checks if there is a user-supplied argument in the command handler’s event arguments, and if there is none, then the function checks the editor’s view:  
  
<CodeContentPlaceHolder>16\</CodeContentPlaceHolder>  
 <CodeContentPlaceHolder>77\</CodeContentPlaceHolder> has to dig a little to get an \<xref:Microsoft.VisualStudio.Text.Editor.IWpfTextView*> view of the code.  If you trace through <CodeContentPlaceHolder>78\</CodeContentPlaceHolder>, <CodeContentPlaceHolder>79\</CodeContentPlaceHolder>, and <CodeContentPlaceHolder>80\</CodeContentPlaceHolder>, you can see how to do that.  The following is the relevant code abstracted, starting with the current selection, then getting the selection’s frame, then getting the frame’s DocView as an \<xref:Microsoft.VisualStudio.TextManager.Interop.IVsTextView*>, then getting an \<xref:Microsoft.VisualStudio.TextManager.Interop.IVsUserData*> from the IVsTextView, then getting a view host, and finally the IWpfTextView:  
  
<CodeContentPlaceHolder>17\</CodeContentPlaceHolder>  
 Once you have an IWpfTextView, you can get the column where the caret is located:  
  
<CodeContentPlaceHolder>18\</CodeContentPlaceHolder>  
 With the current column in hand where the user clicked, the code just calls on the settings manager to add or remove the column.  The settings manager fires the event to which all <CodeContentPlaceHolder>81\</CodeContentPlaceHolder> objects listen.  When the event fires, these objects update their associated text views with new column guide settings.  
  
## Invoking Command from the Command Window  
 The column guides sample enables users to invoke two commands from the Command Window as a form of extensibility.  If you use the **View &#124; Other Windows &#124; Command Window** command, you can see the Command Window.  You can interact with the command window by entering “edit.”, and with command name completion and supplying the argument 120, you have the following:  
  
<CodeContentPlaceHolder>19\</CodeContentPlaceHolder>  
 The pieces of the sample that enable this are in the .vsct file declarations, the <CodeContentPlaceHolder>82\</CodeContentPlaceHolder> class constructor when it hooks up command handlers, and the command handler implementations that check event arguments.  
  
 You saw “<CodeContentPlaceHolder>83\</CodeContentPlaceHolder>” in the .vsct file as well as placements in the Edit main menu even though we do not show the commands in the **Edit** menu UI.  Having them on the main Edit menu gives them names like **Edit.AddColumnGuide**.  The commands group declaration that holds the four commands placed the group on the Edit menu directly:  
  
<CodeContentPlaceHolder>20\</CodeContentPlaceHolder>  
 The buttons section later declared the commands <CodeContentPlaceHolder>84\</CodeContentPlaceHolder> to keep them invisible on the main menu and declared them with <CodeContentPlaceHolder>85\</CodeContentPlaceHolder>:  
  
<CodeContentPlaceHolder>21\</CodeContentPlaceHolder>  
 You saw the command handler hook up code in the <CodeContentPlaceHolder>86\</CodeContentPlaceHolder> class constructor provided a description of the allowed parameter:  
  
<CodeContentPlaceHolder>22\</CodeContentPlaceHolder>  
 You saw the <CodeContentPlaceHolder>87\</CodeContentPlaceHolder> function checks <CodeContentPlaceHolder>88\</CodeContentPlaceHolder> for a value before checking the editor’s view for a current column:  
  
<CodeContentPlaceHolder>23\</CodeContentPlaceHolder>  
## Trying Your Extension  
 You can now press **F5** to execute your Column Guides extension.  Open a text file and use the editor’s context menu to add guide lines, remove them, and change their color.  You need to click in text (not whitespace passed the end of the line) to add a column guide, or the editor adds it to the last column on the line.  If you use the Command Window and invoke the commands with an argument, you can add column guides anywhere.  
  
 If you want to try different command placements, change names, change icons, and so on, and you have any problems with Visual Studio showing you the latest code in menus, you can reset the experimental hive in which you are debugging.  Bring up the **Windows Start Menu** and type “reset”.  Look for and invoke the command **Reset the Next Visual Studio Experimental Instance**.  This cleans up the experimental registry hive of all extension components.  It does not clean out settings from components, so any guides you had when you shut down Visual Studio’s experimental hive will still be there when your code reads the settings store on next launch.  
  
## Finished Code Project  
 There will soon be a github project of Visual Studio Extensibility samples, and the completed project will be there.  We will update this topic to point there when that happens.  The completed sample project may have different guids and will have a different bitmaps strip for the command icons.  
  
 You can try out a version of the column guides feature with this Visual Studio Gallery[extension](https://visualstudiogallery.msdn.microsoft.com/da227a0b-0e31-4a11-8f6b-3a149cf2e459?SRC=Home).  
  
## See Also  
 [Inside the Editor](../vs140/inside-the-editor.md)   
 [Extending the Editor](../vs140/extending-the-editor-and-language-services.md)   
 [Editor Extension Points](../vs140/language-service-and-editor-extension-points.md)   
 [Extending VS Menus and Commands](../vs140/extending-menus-and-commands.md)   
 [Adding a Sub Menu to a Menu](../vs140/adding-a-submenu-to-a-menu.md)   
 [Using Extension Editor Item Templates](../vs140/creating-an-extension-with-an-editor-item-template.md)