---
title: "Compiler Error C2440"
ms.custom: na
ms.date: "09/22/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: na
ms.suite: na
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: na
ms.topic: "error-reference"
f1_keywords: 
  - "C2440"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "C2440"
ms.assetid: 36e6676c-f04f-4715-8ba1-f096c4bf3b44
caps.latest.revision: 31
translation.priority.ht: 
  - "de-de"
  - "ja-jp"
---
# Compiler Error C2440
'conversion' : cannot convert from 'type1' to 'type2'  
  
 The compiler cannot cast from '<CodeContentPlaceHolder>10\</CodeContentPlaceHolder>' to '<CodeContentPlaceHolder>11\</CodeContentPlaceHolder>'.  
  
## Example  
 C2440 can be caused if you attempt to initialize a non-const <CodeContentPlaceHolder>12\</CodeContentPlaceHolder> (or <CodeContentPlaceHolder>13\</CodeContentPlaceHolder>) by using a string literal in C++ code, when the compiler conformance option [/Zc:strictStrings](../vs140/-zc-strictstrings--disable-string-literal-type-conversion-.md) is set. In C, the type of a string literal is array of <CodeContentPlaceHolder>14\</CodeContentPlaceHolder>, but in C++, it is array of <CodeContentPlaceHolder>15\</CodeContentPlaceHolder>. This sample generates C2440:  
  
<CodeContentPlaceHolder>0\</CodeContentPlaceHolder>  
## Example  
 C2440 can also be caused if you attempt to convert a pointer to member to void*. The next sample generates C2440:  
  
<CodeContentPlaceHolder>1\</CodeContentPlaceHolder>  
## Example  
 C2440 can also be caused if you attempt to cast from a type that is only forward declared but not defined. This sample generates C2440:  
  
<CodeContentPlaceHolder>2\</CodeContentPlaceHolder>  
## Example  
 The C2440 errors on lines 15 and 16 of the next sample are qualified with the <CodeContentPlaceHolder>16\</CodeContentPlaceHolder> message. (A UDT is a user-defined type, such as a class, struct, or union.) These kinds of incompatibility errors are caused when the calling convention of a UDT specified in the return type of a forward declaration conflicts with the actual calling convention of the UDT and when a function pointer is involved.  
  
 In the example, first there are forward declarations for a struct and for a function that returns the struct; the compiler assumes that the struct uses the C++ calling convention. Next is the struct definition, which, by default, uses the C calling convention. Because the compiler does not know the calling convention of the struct until it finishes reading the entire struct, the calling convention for the struct in the return type of <CodeContentPlaceHolder>17\</CodeContentPlaceHolder> is also assumed to be C++.  
  
 The struct is followed by another function declaration that returns the struct, but at this point, the compiler knows that the struct's calling convention is C++. Similarly, the function pointer, which returns the struct, is defined after the struct definition so that the compiler knows that the struct uses the C++ calling convention.  
  
 To resolve C2440 that occurs because of incompatible calling conventions, declare functions that return a UDT after the UDT definition.  
  
<CodeContentPlaceHolder>3\</CodeContentPlaceHolder>  
## Example  
 C2440 can also occur if you assign zero to an interior pointer:  
  
<CodeContentPlaceHolder>4\</CodeContentPlaceHolder>  
## Example  
 C2440 can also occur for an incorrect use of a user-defined conversion. For more information about user-defined conversions, see [User-Defined Conversions](../vs140/user-defined-conversions--c---cli-.md)). This sample generates C2440:  
  
<CodeContentPlaceHolder>5\</CodeContentPlaceHolder>  
## Example  
 C2440 can also occur if you try to create an instance of a Visual C++ array whose type is a \<xref:System.Array*>.  For more information, see [array](../vs140/arrays--c---component-extensions-.md).  The next sample generates C2440:  
  
<CodeContentPlaceHolder>6\</CodeContentPlaceHolder>  
## Example  
 C2440 can also occur because of changes in the attributes feature.  The following sample generates C2440.  
  
<CodeContentPlaceHolder>7\</CodeContentPlaceHolder>  
## Example  
 The Visual C++ compiler no longer allows the [const_cast Operator](../vs140/const_cast-operator.md) to down cast when source code that uses **/clr** programming is compiled.  
  
 To resolve this C2440, use the correct cast operator. For more information, see [Casting Operators](../vs140/casting-operators.md).  
  
 This sample generates C2440:  
  
<CodeContentPlaceHolder>8\</CodeContentPlaceHolder>  
## Example  
 C2440 can also be generated by using **/clr:oldSyntax**:  
  
<CodeContentPlaceHolder>9\</CodeContentPlaceHolder>