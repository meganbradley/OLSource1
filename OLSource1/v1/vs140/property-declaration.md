---
title: "Property Declaration"
ms.custom: na
ms.date: "09/22/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: na
ms.suite: na
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: na
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "__property keyword"
  - "declaring properties, C++"
  - "property keyword [C++]"
ms.assetid: de169378-a8b8-49f4-a586-76bffc9b5c9f
caps.latest.revision: 13
translation.priority.ht: 
  - "de-de"
  - "ja-jp"
---
# Property Declaration
The way to declare a property in a managed class has changed from Managed Extensions for C++ to [!INCLUDE[cpp_current_long](../vs140/includes/cpp_current_long_md.md)].  
  
 In the Managed Extensions design, each <CodeContentPlaceHolder>4\</CodeContentPlaceHolder> or <CodeContentPlaceHolder>5\</CodeContentPlaceHolder> property accessor is specified as an independent method. The declaration of each method is prefixed with the <CodeContentPlaceHolder>6\</CodeContentPlaceHolder> keyword. The method name begins with either <CodeContentPlaceHolder>7\</CodeContentPlaceHolder> or <CodeContentPlaceHolder>8\</CodeContentPlaceHolder> followed by the actual name of the property (as visible to the user). Thus, a <CodeContentPlaceHolder>9\</CodeContentPlaceHolder> providing an <CodeContentPlaceHolder>10\</CodeContentPlaceHolder> coordinate <CodeContentPlaceHolder>11\</CodeContentPlaceHolder> property would name it <CodeContentPlaceHolder>12\</CodeContentPlaceHolder> and the user would invoke it as <CodeContentPlaceHolder>13\</CodeContentPlaceHolder>. This naming convention and separate specification of methods actually reflects the underlying runtime implementation of the property. For example, here is our <CodeContentPlaceHolder>14\</CodeContentPlaceHolder> with a set of coordinate properties:  
  
<CodeContentPlaceHolder>0\</CodeContentPlaceHolder>  
 This spreads out the functionality associated with a property and requires the user to lexically unify the associated sets and gets. Moreover, it is verbose. In the new syntax, which is more like that of C#, the <CodeContentPlaceHolder>15\</CodeContentPlaceHolder> keyword is followed by the type of the property and its unadorned name. The <CodeContentPlaceHolder>16\</CodeContentPlaceHolder> and <CodeContentPlaceHolder>17\</CodeContentPlaceHolder> access methods are placed within a block following the property name. Note that unlike C#, the signature of the access method is specified. For example, here is the code example above translated into the new syntax.  
  
<CodeContentPlaceHolder>1\</CodeContentPlaceHolder>  
 If the access methods of the property reflect distinct access levels â€“ such as a <CodeContentPlaceHolder>18\</CodeContentPlaceHolder> and a <CodeContentPlaceHolder>19\</CodeContentPlaceHolder> or <CodeContentPlaceHolder>20\</CodeContentPlaceHolder>, an explicit access label can be specified. By default, the access level of the property reflects that of the enclosing access level. For example, in the above definition of <CodeContentPlaceHolder>21\</CodeContentPlaceHolder>, both the <CodeContentPlaceHolder>22\</CodeContentPlaceHolder> and <CodeContentPlaceHolder>23\</CodeContentPlaceHolder> methods are <CodeContentPlaceHolder>24\</CodeContentPlaceHolder>. To make the <CodeContentPlaceHolder>25\</CodeContentPlaceHolder> method <CodeContentPlaceHolder>26\</CodeContentPlaceHolder> or <CodeContentPlaceHolder>27\</CodeContentPlaceHolder>, the definition would be revised as follows:  
  
<CodeContentPlaceHolder>2\</CodeContentPlaceHolder>  
 The scope of an access keyword within a property extends until either the closing brace of the property or the specification of an additional access keyword. It does not extend beyond the definition of the property to the enclosing access level within which the property is defined. In the above declaration, for example, <CodeContentPlaceHolder>28\</CodeContentPlaceHolder> is a public method.  
  
 Writing the set/get properties for the three <CodeContentPlaceHolder>29\</CodeContentPlaceHolder> coordinates involves three steps:  
  
1.  declare a private state member of the appropriate type.  
  
2.  return it when the user wishes to get its value.  
  
3.  assign it the new value.  
  
 In the new syntax, a shorthand property syntax is available which automates this usage pattern:  
  
<CodeContentPlaceHolder>3\</CodeContentPlaceHolder>  
 The interesting side effect of the shorthand property syntax is that although the backstage state member is generated by the compiler, it is not accessible within the class except through the set/get accessors.  
  
## See Also  
 [Member Declarations within a Class or Interface](../vs140/member-declarations-within-a-class-or-interface--c---cli-.md)   
 [property](../vs140/property---c---component-extensions-.md)